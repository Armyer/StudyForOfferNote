### **什么是操作系统？**

操作系统本质上就是用于连接用户和计算机硬件的过渡件。其中还包括了内核态和外壳两个大方面，其中内核是操作计算机硬件的核心，使用它可以实现操作管理系统的进程、内存、设备驱动程序、文件和网络系统等等方面。可大致分为以下：

* 设备管理：完成设备的请求、释放、启动等功能
* 文件管理：完成文件的读写、增加删除等功能
* 进程通信：完成进程之间的消息传递或信号传递等功能
* 进程控制：完成进程的创建、撤销、阻塞及唤醒等功能
* 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能


### 进程间的通信方式

| 名称 |说明  |
| --- | --- |
|管道/匿名管道用于具有亲缘关系的父子进程间或者兄弟进程之间的通信  |  |
|有名管道  |克服上面缺点，遵循先进先出。以磁盘文件方式存在，可实现本机任意两个进程通信  |
|信号  |一种复杂的通信方式，用于通知接收进程某个事件已经发生  |
|消息队列  |消息队列克服信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。可实现消息的随机查询，消息不一定要以先进先出的次序读取，也可按消息的类型读取  |
| 信号量 |是一个计数器，用于多进程对共享数据的访问，意图在于进程间同步，避免竞争条件  |
|共享内存  |使多个进程可访问同一块内存空间，不同进程可以及时查看到对方进程中对共享内存中数据的更新。需要依靠同步操作，如互斥锁和信号量，可以说是最有用的进程间通信方式  |
|套接字  |主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TVP/IP的网络通信的基本操作单元。  |


### 线程间的同步方式


| 名称 |说明  |
| --- | --- |
|互斥量  |只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可保证公共资源不会被多个线程同时访问。Java中的synchronized即为该机制  |
|信号量  |允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量  |
|事件  |Wait/Notify，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作  |


### 进程的调度算法


| 名称 |说明  |
| --- | --- |
|先到先服务调度算法FCFS  |从就绪队列中选择一个最先进入该队的进程为之分配资源，立即执行/阻塞放弃占用CPU  |
|短作业优先调度算法  |从就绪队列中选出一个估计运行时间最短的进程为之分配资源，立即执行到完成/阻塞放弃占用CPU  |
| 时间片轮转调度算法 |最古老，最简单，最公平且使用最广的算法。每个进程分配一个时间段，为该进程允许运行的时间  |
| 多级反馈队列调度算法 |前几种都有一定的局限性，被公认的一种较好的进程调度算法，UNIX操作系统采取的便是该调度算法  |
|优先级调度  |为每个流程分配优先级，首先执行具有最高优先级的进程，以此类推。相同优先级进程以FCFS方式执行。     |


### 内存管理机制
简单的分为练习分配管理方式和非连续分配管理方式。
| 名称 |说明  |
| --- | --- |
|块式管理  |较古老的方式，将内存分为固定几个大小的块，每块只包含一个进程。容易过多分配，造成碎片  |
|页式管理  |内存分为大小相等且固定的一页一页的形式，页较小，提高了内存利用率，减少碎片。页式管理通过页表对应逻辑地址和物理地址。  |
|段式管理  |将内存分为一段段的，每一段空间要比一页的空间小很多，但每个段是有实际意义的，每个段定义了一组逻辑以以。有主程序段MAIN，子程序段X，数据段D以及栈段S等。段式管理通过段表对应逻辑地址和物理地址。  |
|段页式管理  | 把内存分为若干个段，每段又分成若干页，也就是段页式管理机制中段与段之间以及段的内部都是离散的。 |


**补充**：
页表管理机制中有两个重要的概念：快表和多级页表，用于解决了页表管理中很重要的两个问题。
1.虚拟地址到物理地址的转换要快
2.解决虚拟地址空间大，页表也会很大的问题

| 名称 |说明  |
| --- | --- |
| 快表TLB |解决虚拟地址到物理地址的转换速度。把快表理解成一种特殊的高速缓冲存储器Cache，作用与页表相似，但提高了访问速率。  |
| 多级页表 | 解决了把全部页表一只存放在内存中占用过多空间。典型的时间换空间的场景。 |


### 虚拟内存和虚拟存储器

虚拟内存：可以让程序拥有超过物理内存大小的可用内存空间。虚拟内存为每个进程提供了一个一致的、私有的地址空间，让每个进程产生了一种自己在独享主存的错觉。每个进程拥有一片连续完整的内存空间。**虚拟内存重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。**

**虚拟内存的技术实现：**

| 名称 |说明  |
| --- | --- |
| 请求分页存储管理 |建立在分页管理上，支持虚拟存储器而增加了请求调页功能和页面置换功能。  |
| 请求分段存储管理 | 建立在分段存储管理上，增加了请求调段功能、分段置换功能。 |
| 请求段页式管理 |两者结合。  |
**请求分页与分页存储管理不同点：**
请求分页或是分页管理根本区别在于是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。请求分页不要求将作业全部地址空间同时装入主存，因为请求分页可以提供虚存，而分页存储管理不能提供。
但也有**相同点：**
1.需要一定容量的内存和外村
2.发生缺页中断：执行的指令或访问的数据尚未在内存，则由处理器通知OS将相应的页面或段调入到内存。
3.虚拟地址空间：逻辑地址到物理地址的转换。

#### 缺页中断补充（即页面置换算法）：

| 名称 |说明  |
| --- | --- |
|OPT页面置换算法（最佳页面置换算法）|理想情况，不可能实现，一般作为衡量其它置换算法的方法  |
|FIFO页面置换算法（先进先出）  |总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰  |
|LRU页面置换算法（最近未使用）  |每个页面赋予一个访问字段，用于记录一个页面自上次被访问以来所经历的时间T。当需要淘汰时，选择现有页面中其T值最大的。  |
| LFU页面置换算法（最少使用） |维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面。  |

**局部性原理：**
时间局部性：程序中的某条指令一旦执行，不久以后该指令可能再次执行。如果某数据被访问，不久以后数据可能再次被访问。典型原因是程序中存在着大量的循环操作。
空间局部性：一旦程序访问某个存储单元，不久以后，附近的存储单元也将被访问。因为指令通常是顺序存、顺序执行的，数据也一般是以向量、数组、表等形式存储的。

#### 虚拟存储器
基于局部性原理，程序装入时只装入一部分，其他部分留在外存，就可以启动程序执行。外存往往比内存大很多，所以我们运行的软件的内存大小实际上就是可以比计算机系统实际的内存大。感觉上，计算机好像为用户提供了一个比实际内存大的多的存储器。

